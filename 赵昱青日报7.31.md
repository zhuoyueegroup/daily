# 日报

## 2019.7.31

### 内容

- ##### 今日学习内容

  - 学了生成器
  - 学了promise原理 没太搞懂
  - 面试题整理(每日更新)  [https://github.com/YokongMaple/--](https://github.com/YokongMaple/--)

- ##### 没有解决的问题

  - 无

- ##### 明天的学习计划

  - 做自己找的简单的vue项目
  - 整理面试题

```javascript
// 首先我的构造函数里有一个参数是个函数 代表一个异步的任务
// 这个函数里有两个参数都是函数，一个是成功的回调另一个是失败的回调
// 这里我把 这个异步任务函数设置为task
function Promise(task){
    let that=this; //我缓存一下这个this，指向的就是promise的实例
    that.status='pending';//实例上有个初始状态默认是pending;
    //存放着这个promise所有成功的回调函数的数组
    that.onResolvedCallbacks=[];
    //存放着这个promise所有失败的回调函数的数组
    that.onRejectedCallbacks=[];
    that.successed=undefined;
    that.defated=undefined;
    //这是成功的回调函数
    function resolve(value){
        // 成功后那么状态就应该由pending变为fulfilled,这里加个if判断是因为只有再pending下才能转换为fulfilled也就是只有初始态才能到成功态
        if(that.status=='pending'){
            that.status='fulfilled';
            //成功时候的回调函数会执行，并且会传一个参数，我们把这个参数保存到这个promise对象上的successed属性！
            that.successed=value;
            that.onResolvedCallbacks.forEach(item=>item(reason))
        }
    
    }
    // 这是失败的回调函数
    function reject(reason){
        // 失败后那么状态就应该由pending变为rejected,这里加个if判断是因为只有在pending下才能转换为rejected也就是只有初始态才能到失败态
        if(that.status=='pending'){
            that.status='rejected';
            that.defated=reason;
            that.onRejectedCallbacks.forEach(item=>item(reason))
        }
    }



    //既然传入了这个函数那么就要执行这个异步任务函数,这个函数有两个回调函数之前说过一个是resolve,一个是reject，这里我们也要调用他们，定义在上面定义
    task(resolve,reject);
}
// 一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因。
//上面是官方定义，实例有个then方法用来执行，所以这里我们挂载到Promise的原型上
//then方法接受两个参数，也都是函数，第一个是成功时候执行的resolve，第二个是失败时候执行的reject
Promise.prototype.then=function(onFulfilled,onReject){
    let that=this;
    //我们如何通过它来执行resolve和reject方法呢。
    // 我们可以在Promise上加两个数组，一个数组用来存放成功的时候执行的函数，另一个来存放失败的时候执行的函数，我们传入进去后，那么promise就能通过遍历这两个数组来得到对应的方法并且执行！
    that.onResolvedCallbacks.push(onFulfilled);//把成功时候要执行的函数添加到成功函数数组中
    that.onRejectedCallbacks.push(onReject);//把失败时候要执行的函数添加到失败函数数组中

}

module.exports=Promise
```